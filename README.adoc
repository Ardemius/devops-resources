= DevOps workflow
Thomas SCHWENDER <icon:github[] https://github.com/Ardemius/[GitHub] / icon:twitter[role="aqua"] https://twitter.com/thomasschwender[@thomasschwender]>
// Handling GitHub admonition blocks icons
ifndef::env-github[:icons: font]
ifdef::env-github[]
:status:
:outfilesuffix: .adoc
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
:warning-caption: :warning:
endif::[]
:imagesdir: ./images
:source-highlighter: highlightjs
:highlightjs-languages: asciidoc
// We must enable experimental attribute to display Keyboard, button, and menu macros
:experimental:
// Next 2 ones are to handle line breaks in some particular elements (list, footnotes, etc.)
:lb: pass:[<br> +]
:sb: pass:[<br>]
// check https://github.com/Ardemius/personal-wiki/wiki/AsciiDoctor-tips for tips on table of content in GitHub
:toc: macro
:toclevels: 4
// To number the sections of the table of contents
//:sectnums:
// Add an anchor with hyperlink before the section title
:sectanchors:
// To turn off figure caption labels and numbers
:figure-caption!:
// Same for examples
//:example-caption!:
// To turn off ALL captions
// :caption:

toc::[]

Ma repr√©sentation d'un *worflow DevOps complet* sous forme de sch√©ma, avec la *description de ses phases*.

== Sch√©ma d'un workflow DevOps et de ses phases

image::DevOps%20AceTP.png[title="DevOps Workflow"]

{nbsp} +
R√©alis√© int√©gralement avec https://inkscape.org/en/[Inkscape]. +
Sous licence https://en.wikipedia.org/wiki/Creative_Commons_license[Creative Commons *BY*] image:https://upload.wikimedia.org/wikipedia/commons/3/3c/Cc-by_new.svg[CC BY, 25, 25]

[TIP] 
====
* Les fichiers *PNG* and *SVG* du sch√©ma sont disponibles dans le r√©pertoire _images_ du repo üòâ 
* Mes *notes de recherche* sur les phases sont dans le fichier link:devops-workflow_notes.adoc[]
====

== Continuous "Everything"

Cette section a pour objectif d'expliquer de quoi il est question quand on parle de "Continuous Integration", "Continuous Delivery", "Continuous Deployment" et de CI/CD.

* *Continuous Integration* (*CI*) : +
L'Int√©gration Continue s'aligne avec les phases *CODE*, *BUILD* et *TEST* du pr√©c√©dent sch√©ma.
{lb}
Cette pratique consiste en l'*int√©gration r√©guli√®re* par les d√©veloppeurs des modifications de leur code source dans un *gestionnaire de code centralis√©*, et en *l'automatisation de la conduite de tests* visant √† d√©tecter l'introduction de r√©gressions dans le code. 

* *Continuous Delivery* (*CD*) : +
La Livraison Continue *compl√®te l'Int√©gration Continue* √† laquelle elle ajoute les phases *RELEASE* et *DEPLOY* du pr√©c√©dent sch√©ma. +
Une pr√©cision importante cependant : dans le cas de la Livraison Continue, le *d√©ploiement*, associ√© √† la phase DEPLOY, est le r√©sultat d'une *action manuelle* et NON d'une ex√©cution automatique.
{lb}
En plus des objectifs de la CI, la Livraison Continue rajoute les objectifs suivants : 
    ** *L'automatisation de la cr√©ation des livrables* de l'application
    ** *L'automatisation du d√©ploiement et de la configuration de ces livrables dans les diff√©rents environnements de qualification* (par exemple environnements d'int√©gration, de recette, de pre-prod) √† l'exception de la production qui n√©cessite une approbation manuelle
    ** *L'automatisation de la conduite de tests* dans les diff√©rents environnements o√π les livrables ont √©t√© d√©ploy√©s. +
    Les livrables ne pouvant √™tre "promus" dans un environnement sup√©rieur qu'√† partir du moment o√π ils ont valid√© les tests de l'environnement pr√©sent. +
    Exemple : les livrables doivent valider les tests sp√©cifiques √† l'environnement d'int√©gration avant d'√™tre promus (d√©ploy√©s) en environnement de recette.

* *Continuous Deployment* (de nouveau "*CD*", comme pour le Continous Delivery) : +
*D√©ploiement Continu et Livraison Continue sont similaires* √† la seule diff√©rence que la Livraison Continue n√©cessite une action manuelle pour le d√©ploiement des livrables en environnement de production (ce qui correspond √† la v√©ritable "MEP / Mise En Production" de l'application), alors que le D√©ploiement Continu r√©alise la mise en production automatiquement.

.Continous Integration, Delivery and Deployment (https://aws.amazon.com/fr/devops/continuous-delivery/)
image:continuous-integration-delivery-deployment.png[]

* *CI/CD* : +
L'expression "CI/CD" d√©signe simplement la combinaison de 2 ou 3 des pratiques pr√©c√©dentes : 
** Continuous Integration (CI) et Continuous Delivery (CD)
** Continuous Integration (CI) et Continuous Delivery (CD) et Continous Deployment (CD)
{lb}
On parlera souvent de "*cha√Æne de CI/CD*" pour d√©signer l'ensemble d'outils et le workflow d'√©tapes permettant d'impl√©menter les pratiques de CI et CD.

* *DevOps* : +
Le DevOps, contraction de *Dev* pour Development (D√©veloppement) et *Ops* pour Operations (Exploitation), d√©signe √† la fois un ensemble de pratiques (auxquelles appartiennent celles pr√©c√©demment d√©crites) et d'outils et une philosophie / culture de travail.
{lb}
Son but est d'am√©liorer la capacit√© d'une entreprise √† *livrer rapidement* des applications et services, de *garantir leur qualit√©*, de *faciliter leur √©volution* afin au final de *gagner en comp√©titivit√©*.
{lb}
On pourra parler aussi bien de "pratiques DevOps" que de "mouvement DevOps", d'"approche DevOps", ou encore de "cycle (de vie) DevOps" ou autre "pipeline" et "workflow" DevOps.

== Description des phases

=== PLAN

La phase de planification / conception concerne tout ce qui a lieu AVANT que l'√©quipe de d√©veloppement ne d√©bute l'√©criture du code. +
C'est le moment o√π l'on va construire la roadmap produit afin de guider les d√©veloppements √† venir.

Cette roadmap est g√©n√©ralement enregistr√©e et suivie √† l'aide d'un *outil de gestion de projet* comme Jira, Trello, Azure DevOps (fonctionnalit√© "Boards"), etc.

=== CODE

C'est durant cette phase que l'√©quipe de d√©veloppement impl√©mente les stories de la roadmap produit, et donc "√©crit le code".

Pour ce faire, les d√©veloppeurs utilisent un ensemble d'*outils* (IDE et leurs plugins, outil de mod√©lisation, utilitaires divers, etc.), *langages de d√©veloppement* (Java, Python, etc.), *frameworks* (Spring, Hibernate, etc.), *librairies* (Guava, Apache Commons, etc.) et *sp√©cifications* (JAX-RS, CDI, JSON-P, etc.), pour certains *d√©finis au niveau de l'organisation*, pour d'autres *sp√©cifiques au projet*.

Une fois √©crit, le code doit √™tre sauvegard√© et partag√© dans l'√©quipe √† l'aide de solutions d'h√©bergement de code (*Source Code Repository Manager*) s'appuyant sur un logiciel de *SCM* (*Source Code Management*). +
*Git* est actuellement le SCM le plus utilis√© au monde, et parmi les repo manager populaires s'appuyant dessus nous trouvons aujourd'hui GitHub, GitLab, Bitbucket pour ne citer qu'eux.

==== Strat√©gie de branching Git

2 types de strat√©gies de gestion de branches ("branching strategies") sont globalement utilis√©es aujourd'hui (2022) sur le march√© :

    * Les workflows dits de "*feature branching*" auxquels appartiennent Git Flow, GitHub flow et GitLab flow.
    {lb}
    image:git-branching-strategies_feature-branching.png[width=800]

    * Les workflow dits "*trunk-based*" (on parlera de "trunk-based development")
    {lb}
    image:git-branching-strategies_trunk-based.png[width=600]

[.small]#Source des 2 pr√©c√©dents sch√©mas : https://learn.microsoft.com/fr-fr/archive/blogs/technet/devops/a-git-workflow-for-continuous-delivery#

[NOTE]
====
Depuis quelques ann√©es maintenant, le *trunk-based development* est redevenu la *strat√©gie de branching la plus utilis√©e*, devant le feature branching qui avait pris le lead lors de l'adoption massive des outils de type DVCS (bas√©s sur Git). +
-> C'est principalement la cons√©quence des *difficult√©s de merge* rencontr√©es avec le *feature branching* du fait du grand nombre de branches manipul√©es ("feature branches hell")
====

=== BUILD

La phase de BUILD est celle o√π le code source va √™tre r√©cup√©r√© (du pr√©c√©dent repo manager) puis build√© afin de pouvoir √™tre test√©.

Le r√©sultat du build, souvent appel√© "*archive*" (JAR pour Java ARchive, WAR pour Web ARchive, etc.), a pour vocation d'√™tre ensuite d√©ploy√©, test√© et valid√© dans les diff√©rents environnements du projet (par exemple DEVELOPPEMENT, INTEGRATION, RECETTE, PRE-PRODUCTION et finalement PRODUCTION).

[NOTE]
====
Il est √† noter que l'on devrait toujours *ne builder qu'une unique fois* une archive, puis d√©ployer et tester progressivement cette m√™me archive dans les diff√©rents environnements et NON builder une archive sp√©cifique par environnement.
====

La *cr√©ation de l'archive* √† partir du code source est r√©alis√©e √† l'aide d'un *outil de build*. +
Parmi les plus connus on retrouve Maven, Gradle, Ant, NPM, etc.

Le *d√©clenchement du build* est g√©n√©ralement r√©alis√© par un outil d'automatisation, de type *serveur d'int√©gration continue*. +
L'√©l√©ment d√©clencheur du build ("trigger") est soit une action manuelle, soit la d√©tection en temps presque r√©el d'une modification du code dans le repo manager (pr√©sence d'un nouveau commit modifiant le code). +
Les serveurs d'int√©gration d√©l√®gue ensuite la cr√©ation de l'archive aux outils de build vus pr√©c√©demment.
Parmi les serveurs d'int√©gration continue les plus connus on retrouve Jenkins, Travis CI, GitLab CI, Azure DevOps, etc.

.Exemple de workflow avec Jenkins
image:jenkins-workflow-example.jpg[]

=== TEST

Une fois build√©s, les archives sont d√©ploy√©s dans un environnement de qualification o√π plusieurs s√©ries de tests, manuels (UAT ou tests de recette) et / ou automatiques (tests d'int√©gration, d'API, de s√©curit√©, etc.) sont d√©roul√©s. +
Les archives peuvent √©galement √™tre d√©ploy√©es dans plusieurs environnements de qualification, chacun √©tant l'objet de tests de natures diff√©rentes.

=== RELEASE

La phase de release est celle o√π le *livrable de production* (certains outils parleront de "package" ou "deployment package") va √™tre cr√©√© en combinant les archives pr√©c√©demment build√©es et test√©es avec les diff√©rents param√®tres permettant de les d√©dier √† l'environnement cibl√© (package = archives + fichiers de param√©trage).

Le livrable de production / package ainsi cr√©√© sera ensuite stock√© dans un *r√©f√©rentiel sp√©cifique*. 
Suivant la nature du livrable, ce r√©f√©rentiel pourra √™tre soit un *repository manager* (Nexus et Artifactory sont les plus utilis√©s), ou un outil d√©di√© (Digital.ai Deploy (anciennement XL Deploy) )

=== DEPLOY

La phase de DEPLOY correspond au d√©ploiement, √† l'installation du livrable de production de la phase RELEASE en environnement de PROD. +
Ce d√©ploiement peut √™tre soit manuel dans le cadre d'une approche *Continuous Delivery*, soit *automatique* dans le cadre du *Continuous Deployment*.

Les principaux outils permettant de configurer un environnement √† partir des √©l√©ments contenus dans le livrable de production sont appel√©s *outils d'automatisation et de gestion de configuration*, parmi lesquels on peut citer *Ansible*, *XL Deploy* (Digital.ai Deploy), *Terraform*. +
Ces outils permettent d'automatiser totalement la proc√©dure de d√©ploiement qui est d√©crite sous forme de fichier (descripteur de d√©ploiement), on parlera d'*Infrastructure-as-Code* (*IaC*)

Et, plut√¥t que de d√©ployer un livrable sur un serveur physique, les *solutions de virtualisation et conteneurisation* sont pl√©biscit√©es. +
Ces derni√®res, conjugu√©es √† l'Infrastructure-as-Code, permettent une meilleure agilit√© et scalabilit√© (capacit√© √† d√©truire, recr√©er et ajouter au besoin un ou plusieurs runtime / environnements), des caract√©ristiques tr√®s demand√©es pour les architectures Cloud et microservices qui multiplient le nombre de serveurs et services. +
Parmi les solutions de virtualisation et de conteneurisation les plus connues : toutes les stacks Cloud actuelles, Docker, Podman, Kubernetes, OpenShift, etc.

=== OPERATE

A ce stade, l'application est d√©ploy√©e en PROD et est en cours de fonctionnement. +
La phase OPERATE regroupe toutes les op√©rations visant √† assurer le bon fonctionnement de l'application. +
On y retrouve : 

    * La mise en place de moyens de *d√©tection de tout comportement anormal* de l'application (*monitoring*), devant donner lieu √† la g√©n√©ration d'une *alerte* (*alerting*). +
    Ces alertes seront stock√©es dans un outil de *gestion de tickets* (Issue Tracking System, ITS).
    {lb}
    Exemples de comportement anormal de l'application : rupture de SLA, serveur down, absence de r√©ponse d'un service, etc.

    * Toutes les *interventions de support*, manuelle ou automatique (script ou autre outil) ayant pour but de corriger un probl√®me afin de revenir √† un comportement normal de l'application.

Parmi les solutions ITS les plus connues : JIRA, ServiceNow, Mantis

.Diff√©rences entre monitoring et alerting
[NOTE]
====
Le *monitoring* est le processus par lequel on maintient la surveillance sur l'√©tat d'un syst√®me. +
Un syst√®me *dit de monitoring* repr√©sente un ensemble d'outils permettant la collecte, le traitement et la visualisation (dashboard, indicateurs visuels, etc.) de donn√©es de t√©l√©m√©trie.

Le monitoring peut √™tre soit :

    * *Proactive* : il est n√©cessaire de consulter r√©guli√®rement les outils de visualisation du monitoring pour se tenir au courant de l'√©tat du syst√®me
    
    * *R√©actif* : c'est le syst√®me de monitoring qui informera automatiquement d'un changement pr√©d√©fini de l'√©tat du syst√®me, via l'envoi de notification ou d'alerte. +
    On parlera d'*alerting*. 

-> L'*alerting* correspond donc √† la capacit√© d'un syst√®me de monitoring de *d√©tecter un changement d'√©tat* donn√© et d'en *notifier* l'√©quipe d'exploitation.
====

Les syst√®mes de monitoring sont souvent regroup√©s en sous-cat√©gories suivant leur sp√©cialit√©.
Voici quelques exemples : 

    * les APM (Application Performance Management) : Dynatrace et Datadog
    * logiciel de supervision : Centreon, Sentry, Nagios
    * Prometheus pour le monitoring de Kubernetes
    * La stack ELK (collecte de donn√©es avec Logstash, requ√™tage avec Elasticsearch et dashboarding avec Kibana)
    * *OpenTelemetry* devient de plus en plus la norme pour l'*envoi* et la *collecte de donn√©es* de t√©l√©m√©trie

=== FEEDBACK & MONITORING

* Monitoring and alerting : https://www.oreilly.com/library/view/effective-monitoring-and/9781449333515/ch01.html
    ** Monitoring "refers to the process of becoming aware of the state of a system"
    ** il y est question de la "*Monitoring's feedback loop*" : +
    "Monitoring's feedback loop is also central to the idea of *Autonomic Computing* (AC), an architecture in which the system is capable of regulating itself and thus enabling self-management and self-healing. +
    AC was inspired by the operation of the human central nervous system. It draws an analogy between it and a complex, distributed information system. Unconscious processes, such as the control over the rate of breath, do not require human effort. The goal of AC is to minimize the need for human intervention in a similar way, by replacing it with self-regulation. Comprehensive monitoring can provide an effective means to achieve this end."
    ** le monitoring implique les *timeseries*

* Monitoring and observability : https://dzone.com/refcardz/getting-started-with-opentelemetry

* Observability : https://dzone.com/refcardz/full-stack-observability-essentials
    ** Observability is "the ability to understand the current state of a system using only its external outputs."
    ** l'article propose une diff√©rence entre observabilit√© et monitoring, et explique que l'observabilit√© est l√† pour augmenter le potentiel du monitoring

    ** "Monitoring is an action; a human or an automated process can do it if they know what signals to look for. It can generate alerts, provide insights, suggest actions, measure traffic or real-user activity, and warn when issues occur."
    ** "Observability, on the other hand, lets you understand why the problem occurred. It is an approach that enables teams to ask questions about the holistic state of a system."

Derri√®re cette notion de "feedback & monitoring", et m√™me d'observabilit√©, il y a l'objectif de mieux comprendre l'application afin d'√™tre capable d'anticiper, de pr√©dire, son comportement futur, et de pr√©venir d'eventuels probl√®mes d'arriver.

* Feedback : Besoin de remonter les cons√©quences d'une action corrective : retour √† la normale ou pas ?

== Schema resources

WARNING: I first designed this schema in 2017/02, and some of the below resources I used when creating it are available anymore.

* https://dzone.com/storage/assets/18140-Continuous-Delivery.pdf[DZone - The DZone guide to Continuous Delivery 2015]: p20/43
* https://dzone.com/storage/assets/17431-docker-jenkins-continuous-delivery.pdf[DZone - Docker / Jenkins - Continuous Delivery]: p15/18
* http://www.bogotobogo.com/DevOps/DevOps_CI_CD_Pipeline_Sample.php
* http://www.rightscale.com/blog/cloud-management-best-practices/continuous-integration-and-delivery-cloud-how-rightscale-does-it
* http://atginfo.com/demystifying-dev-ops-part-1/
* http://agilityladder.nl/it-value/continuous-delivery/: circular graph on Continuous Delivery

Ressources pour la description des phases du cycle DevOps : 

    * https://medium.com/taptuit/the-eight-phases-of-a-devops-pipeline-fda53ec9bba
        ** et pour la description des cycles Continuous Integration, Continuous Delivery, Continuous Deployment : +
        https://medium.com/taptuit/what-is-devops-fb3d044ef659
        
    * https://blog.hubspot.com/website/devops-pipeline

Explication de la Continuous Integration, Continuous Delivery et Continuous deployment

    * Continuous Integration : 
        ** https://aws.amazon.com/fr/devops/continuous-integration/
    * Continuous Delivery : 
        ** https://aws.amazon.com/fr/devops/continuous-delivery/
    * Continuous Deployment : 
        ** https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment
    * Wikipedia pour les 3
        ** https://en.wikipedia.org/wiki/Continuous_integration
        ** https://en.wikipedia.org/wiki/Continuous_delivery
        ** https://en.wikipedia.org/wiki/Continuous_deployment
    * https://www.redhat.com/fr/topics/devops/what-is-ci-cd
        ** pour la CI/CD, voir √©galement la d√©finition simple et efficace de https://fr.wikipedia.org/wiki/CI/CD

Explication sur le DevOps : 

    * https://medium.com/taptuit/what-is-devops-fb3d044ef659
    * https://www.atlassian.com/fr/devops
    * https://fr.wikipedia.org/wiki/Devops
    * https://aws.amazon.com/fr/devops/what-is-devops/
    * https://azure.microsoft.com/en-us/resources/cloud-computing-dictionary/what-is-devops/

